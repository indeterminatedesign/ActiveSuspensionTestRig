#include <Arduino.h>
#include <DFRobot_VL6180X.h>
#include <Wire.h>
#include <AS5600.h>
#include <I2Cdev.h>
#include <MPU6050.h>
#include <Servo.h>

AS5600 encoder;
Servo servo;

MPU6050 mpu;

float_t acceleration;

volatile bool mpuInterrupt = false; // indicates whether MPU interrupt pin has gone high

#define MOTOR_PIN A1
#define INTERRUPT_PIN 2
#define TCAADDR 0x70

uint8_t ret = 1;
volatile uint8_t flag = 0;

DFRobot_VL6180X VL6180X;

void processMPU();
void processEccentricEncoder();
void processSuspensionEncoder();
void processDistanceSensor();
void tcaselect(uint8_t i);
float_t calculateDistance(uint16_t angle);
void moveSuspensionDistance(float_t distance);
void followRoller ();

// ISR for VL6180X
void interrupt()
{
  if (flag == 0)
  {
    flag = 1;
  }
}

float EMA_function(float alpha, float latest, float stored);

void tcaselect(uint8_t i)
{
  if (i > 7)
    return;

  Wire.beginTransmission(TCAADDR);
  Wire.write(1 << i);
  Wire.endTransmission();
}

void setup()
{
  Serial.begin(500000);
  Wire.begin();
  Wire.setClock(400000);
  //******************************************
  // Servo
  //******************************************
  servo.attach(0);
  servo.writeMicroseconds(1500);

  //******************************************
  // MPU
  //******************************************
  tcaselect(3);
  // initialize device
  Serial.println(F("Initializing I2C devices..."));
  mpu.initialize();
  mpu.CalibrateAccel();
  mpu.setFullScaleAccelRange(MPU6050_ACCEL_FS_2);
  mpu.setDLPFMode(MPU6050_DLPF_BW_20);

  Serial.println("Testing device connections...");
  Serial.println(mpu.testConnection() ? "MPU6050 connection successful" : "MPU6050 connection failed");

  //******************************************
  // Motor PWM
  //******************************************
  /*
  analogWriteResolution(10);
  pinMode(MOTOR_PIN, OUTPUT);
  analogWrite(MOTOR_PIN,550);
  */
  tone(MOTOR_PIN, 20000);
  //******************************************
  // Distance Sensor
  //******************************************
  tcaselect(0);

  while (!(VL6180X.begin()))
  {
    Serial.println("Please check that the IIC device is properly connected!");
    delay(1000);
  }
  VL6180X.setInterrupt(/*mode*/ VL6180X_HIGH_INTERRUPT);

  VL6180X.rangeConfigInterrupt(VL6180X_OUT_OF_WINDOW);

  /*Set the range measurement period*/
  VL6180X.rangeSetInterMeasurementPeriod(/* periodMs 0-25500ms */ 30);

  /*Set threshold value*/
  VL6180X.setRangeThresholdValue(/*thresholdL 0-255mm */ 40, /*thresholdH 0-255mm*/ 100);

#if defined(ESP32) || defined(ESP8266) || defined(ARDUINO_SAM_ZERO)
  attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN) /*Query the interrupt number of the D9 pin*/, interrupt, FALLING);
#else
  attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), interrupt, FALLING); // Enable the external interrupt 0, connect INT1/2 to the digital pin of the main control:
                                                                             // UNO(2), Mega2560(2), Leonardo(3), microbit(P0).
#endif

  /*Start continuous range measuring mode */
  VL6180X.rangeStartContinuousMode();
  delay(500);

  //******************************************
  // Encoders
  //******************************************
  tcaselect(1);

  encoder.begin();
}

void loop()
{
  uint32_t stopwatch = micros();
  processEccentricEncoder();

  followRoller ();
  processSuspensionEncoder();
  processDistanceSensor();
  processMPU();
  
  Serial.print(",");
  Serial.print(micros() - stopwatch);
  Serial.println();
  
}

void processEccentricEncoder()
{
  tcaselect(2);
  Serial.print(encoder.readAngle() * 0.0879);
  Serial.print(",");
}
void processSuspensionEncoder()
{
  tcaselect(1);
  Serial.print(encoder.readAngle() * 0.0879);
  Serial.print(",");
}

uint16_t distance;

void processDistanceSensor()
{
  tcaselect(0);
  if (flag == 1)
  {
    flag = 0;
    if (VL6180X.rangeGetInterruptStatus() == VL6180X_OUT_OF_WINDOW)
    {
      /*Get the measured distance data*/
      uint8_t range = VL6180X.rangeGetMeasurement();
      distance = range;
      /*Clear interrupts generated by measuring range*/
      VL6180X.clearRangeInterrupt();
    }
  }
  Serial.print(distance);
  Serial.print(",");
}

float_t previousAcceleration;
void processMPU()
{
  tcaselect(3);
  acceleration = (mpu.getAccelerationZ() / 1671.83) - 9.8; // m/s2
  acceleration = EMA_function(0.4, acceleration, previousAcceleration);
  Serial.print(acceleration);
  previousAcceleration = acceleration;
}

/*************************************************************************************
  EMA Function (Simple Filter)
***********************************************************************************/
float EMA_function(float alpha, float latest, float stored)
{
  return (alpha * latest) + ((1 - alpha) * stored);
}

// 18ms loop time

float_t calculateRollerDistance(uint16_t angle)
{
  const uint16_t offsetAngle = 215;  //145 base offset plus some lag angle
  return sin((angle - offsetAngle) * 0.0174533) * 5;
}

void moveSuspensionDistance(float_t distance)
{
  const float_t armRatio = 1.69;
  float_t servoArmDistance = distance / armRatio;

  float_t servoAngle = atan(servoArmDistance / 25); // In radians
  int16_t microseconds = 318.33 * servoAngle +1450; //Converte angle in radians to microseconds for servo
  servo.writeMicroseconds(microseconds);
  Serial.print(microseconds);
    Serial.print(",");
}

void followRoller ()
{
  tcaselect(2);
  float_t currentAngle = encoder.readAngle() * 0.0879;
  float_t distance = calculateRollerDistance(currentAngle);
  
  moveSuspensionDistance(distance);
}